#!/bin/bash

# Copyright (C) 2017-2018 Andrei Pavel, andrei.pavel@cti.pub.ro
# Licensed under the MIT License

# Get script path and append it to PATH so other scripts are callable.
SCRIPT_PATH="$(dirname "$(readlink -f "${0}")")"
PATH="${PATH}:${SCRIPT_PATH}"

# Header
ARGUMENTS="\
  [\$architecture]              architecture to build for i.e. 'arm',
                               'windows', otherwise build natively
"
. header

# Parse arguments.
while (( ${#} > 0 )); do
  case "${1}" in
  *)
    # architecture i.e. arm, windows
    [[ -z ${architecture} ]] && architecture="${1}" && shift && continue
    # Unrecognized argument
    printf "${RED}ERROR: Unrecognized argument '%s'${RESET}\\n" "${1}" 1>&2; printUsage; exit 1 ;;
  esac; shift
done

function build() {
  if [[ ${architecture} == "arm" ]]; then
    printf '%s\n' "Building for Linux ARM..."
    env GOOS=linux GOARCH=arm GOARM=6 go build -v
  elif [[ ${architecture} == "windows" ]]; then
    printf '%s\n' "Building for Windows..."
    env GOOS=windows GOARCH=amd64 go build -v
  else
    printf '%s\n' "Building..."
    go build -v
  fi
  return ${?}
}

function import_dependencies() {
  pids=()
  for repository in $(printf '%s' "${repositories}"); do
    printf '%s\n' "Getting ${repository}..."
    go get -u "${repository}/..." # & pids+=(${!})
  done
  for pid in "${pids[@]}"; do
    wait "${pid}"
  done
  go clean -r
}

# Get toplevel path.
pushd "${SCRIPT_PATH}" 1> /dev/null
{
  GOPATH=$(git rev-parse --show-toplevel)
}
popd 1> /dev/null

# Export Go variables.
GOBIN=${GOPATH}/bin
export GOPATH
export GOBIN

# Define repositories to import.
repositories="$(cat <<EOF
github.com/go-yaml/yaml
EOF
)"

pushd "${GOPATH}" 1> /dev/null
{
  # Build.
  build
  result=${?}

  if (( result != 0 )); then
    # Import all repositories asynchronously.
    import_dependencies

    # Build again.
    build
    result=${?}
  fi
}
popd 1> /dev/null

# Print result.
if (( result == 0 )); then
  printf '\nDone.\n'
else
  printf '\nErrors were encountered.\n'
  exit 3
fi
